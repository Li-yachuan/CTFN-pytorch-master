import numpy as np
import torch


def cross_entropy_loss2d(inputs, targets, balance=1.1):
    """
    :param inputs: inputs is a 4 dimensional data nx1xhxw
    :param targets: targets is a 3 dimensional data nx1xhxw
    :return:
    """
    n, c, h, w = inputs.size()
    weights = np.zeros((n, c, h, w))
    for i in range(n):
        t = targets[i, :, :, :].cpu().data.numpy()
        pos = (t == 1).sum()
        neg = (t == 0).sum()
        valid = neg + pos
        weights[i, t == 1] = neg * 1. / valid
        weights[i, t == 0] = pos * balance / valid
    weights = torch.Tensor(weights)

    weights = weights.cuda()
    assert inputs.max().item() <= 1 and inputs.min().item() >= 0

    loss = torch.nn.BCELoss(weights, reduction='sum')(inputs, targets)
    return loss
